---
layout: post
title: MySQL的锁现象及原理
categories:
  - Database
published: true
---

叙述与分析MySQL的一些锁现象和原理

shared mode lock: 共享模式锁

# Locking Reads

https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html
https://shiroyasha.io/selecting-for-share-and-update-in-postgresql.html

SELECT FOR SHARE（LOCK IN SHARE MODE）

对读取的任意行设置共享模式锁，其他会话可以读取这些行，但在事务提交前，无法修改它们。并且如果其中任何一行被其它尚未提交的事务更改，查询将等待直到该事务结束，然后使用最新值。

![](/assets/images/2023-07/Pasted%20image%2020230722175558.png)
1. 左一会话开启事务，执行FOR SHARE语句，右二会话可以SELECT、FOR SHARE可以获取值。
2. 左一会话在事务中更新，右二会话执行普通SELECT得到旧值，执行FOR SHARE进入等待。
3. 左一会话提交事务后，右二返回最新值。

![](/assets/images/2023-07/Pasted%20image%2020230722172744.png)
1. 左一开启事务，执行FOR SHARE语句，右二会话执行UPDATE进入等待。
2. 左一提交事务，右二返回，SELECT返回最新值。

## SELECT FOR UPDATE

对于查询的所有行，锁定行和关联的索引条目，与UPDATE语句类似。其他事务将被阻止更新这些行，或者执行FOR SHARE、读取某些事务隔离级别中的数据。

![](/assets/images/2023-07/Pasted%20image%2020230722172123.png)
1. 左一会话开启事务，执行FOR UPDATE语句，右二会话执行普通语句可以获取值。
2. 右二会话执行FOR SHARE/FOR UPDATE进入等待，左二提交事务后，返回值。

![](/assets/images/2023-07/Pasted%20image%2020230722172510.png)
1. 左一会话开启事务，执行FOR UPDATE语句，右二执行UPDATE进入等待。
2. 左一提交事务后，右二返回，SELECT返回最新值。

当事务提交或回滚时，FOR SHARE和FOR UPDATE设置的所有锁都回被释放。

外部语句的锁定不会锁嵌套子查询表中的行，除非子查询也锁定读取子句。

### Theory of `SELECT FOR UPDATE`

从[官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html#:~:text=A%20SELECT%20...%20FOR%20UPDATE%20reads%20the%20latest%20available%20data%2C%20setting%20exclusive%20locks%20on%20each%20row%20it%20reads.%20Thus%2C%20it%20sets%20the%20same%20locks%20a%20searched%20SQL%20UPDATE%20would%20set%20on%20the%20rows.)上可见，`FOR UPDATE`的表现形式与`UPDATE`等效：

> A [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html "13.2.13 SELECT Statement") reads the latest available data, setting exclusive locks on each row it reads. Thus, it sets the same locks a searched SQL [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html "13.2.17 UPDATE Statement") would set on the rows.
> 
>The preceding description is merely an example of how [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html "13.2.13 SELECT Statement") works. In MySQL, the specific task of generating a unique identifier actually can be accomplished using only a single access to the table:

```sql
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);   
SELECT LAST_INSERT_ID();
```

示例：

![](/assets/images/2023-07/Pasted%20image%2020230812170259.png)
对于不存在的索引列，附近行（GAP）。

![](/assets/images/2023-07/Pasted%20image%2020230812173007.png)
对于存在的索引列，会锁住当前行（RECORD）和附近行（GAP）。

![](/assets/images/2023-07/Pasted%20image%2020230812174155.png)
对于范围查询，会锁住符合条件行（RECORD）和附件行（GAP）。

# InnoDB Data Locking

https://dev.mysql.com/blog-archive/innodb-data-locking-part-1-introduction/
https://dev.mysql.com/blog-archive/innodb-data-locking-part-2-locks/
https://dev.mysql.com/blog-archive/innodb-data-locking-part-2-5-locks-deeper-dive/
https://dev.mysql.com/blog-archive/innodb-data-locking-part-3-deadlocks/
https://dev.mysql.com/blog-archive/innodb-data-locking-part-4-scheduling/
https://dev.mysql.com/blog-archive/innodb-data-locking-part-5-concurrent-queues/